<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>任务管理PWA</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #eee;
    }
    #top-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #f9f9f9;
      padding: 8px;
      box-sizing: border-box;
      z-index: 1000;
      border-bottom: 1px solid #ccc;
    }
    /* Layout for inputs and add button */
    #top-bar .inputs {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 8px;
    }
    #top-bar input {
      font-size: 16px;
      padding: 6px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
      -webkit-appearance: none;
    }
    #top-bar input:focus {
      outline: none;
      border-color: #007bff;
    }
    #add-btn {
      font-size: 16px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      min-height: 72px;
    }
    #add-btn:disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    /* Buttons for undo, export, import */
    #controls {
      margin-top: 8px;
    }
    #controls button {
      font-size: 16px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      margin-right: 8px;
    }
    #controls button:disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    /* Canvas area for tasks */
    #canvas {
      position: relative;
      width: 600vw;
      height: 200vh;
      /* Disable default scrolling gestures to implement manual panning */
      touch-action: none;
    }
    .task {
      position: absolute;
      display: block;
      background: #fff;
      color: #000;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 8px;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
    }
    .task-title {
      font-weight: bold;
      margin-bottom: 4px;
      display: inline;
    }
    .task-note {
      margin-top: 4px;
      display: none;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .task.expanded .task-note {
      display: block;
    }
    .delete-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      border: none;
      border-radius: 50%;
      background: red;
      color: #fff;
      font-size: 14px;
      line-height: 18px;
      text-align: center;
      padding: 0;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .delete-btn:active {
      background: darkred;
    }
  </style>
</head>
<body>
  <div id="top-bar">
    <div class="inputs">
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <input type="text" id="task-title-input" placeholder="新任务内容" />
        <input type="text" id="task-note-input" placeholder="新备注内容（可选）" />
      </div>
      <button id="add-btn" disabled>添加任务</button>
    </div>
    <div id="controls">
      <button id="undo-btn" disabled>撤销删除</button>
      <button id="export-btn">导出</button>
      <button id="import-btn">导入</button>
    </div>
  </div>
  <div id="canvas"></div>
  <script>
    // Task data array: each task is { title, note, x, y, expanded }
    let tasks = [];
    let lastDeleted = null;  // store last deleted task for undo
    // Get references to elements
    const taskTitleInput = document.getElementById('task-title-input');
    const taskNoteInput = document.getElementById('task-note-input');
    const addBtn = document.getElementById('add-btn');
    const undoBtn = document.getElementById('undo-btn');
    const exportBtn = document.getElementById('export-btn');
    const importBtn = document.getElementById('import-btn');
    const canvas = document.getElementById('canvas');
    // Enable/disable Add button based on title input
    taskTitleInput.addEventListener('input', () => {
      addBtn.disabled = taskTitleInput.value.trim() === '';
    });
    // Dragging state
    let draggingTask = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let dragging = false;
    let startX = 0;
    let startY = 0;
    let pointerId = null;
    // Canvas panning state
    let panning = false;
    let lastClientX = 0;
    let lastClientY = 0;
    // Render all tasks to the canvas
    function renderTasks() {
      canvas.innerHTML = '';
      tasks.forEach((task, index) => {
        const taskEl = document.createElement('div');
        taskEl.className = 'task';
        taskEl.style.left = task.x + 'px';
        taskEl.style.top = task.y + 'px';
        if (task.expanded) {
          taskEl.classList.add('expanded');
        }
        // Task title and note elements
        const titleEl = document.createElement('div');
        titleEl.className = 'task-title';
        titleEl.textContent = task.title;
        const noteEl = document.createElement('div');
        noteEl.className = 'task-note';
        noteEl.textContent = task.note;
        if (task.note && task.note.length > 0) {
          const arrow = document.createElement('span');
          arrow.className = 'arrow';
          arrow.textContent = task.expanded ? '▼' : '▶';
          arrow.style.fontSize = '14px';
          arrow.style.marginLeft = '4px';
          titleEl.appendChild(arrow);
        }
        taskEl.appendChild(titleEl);
        taskEl.appendChild(noteEl);
        // Delete button
        const delBtn = document.createElement('button');
        delBtn.className = 'delete-btn';
        delBtn.textContent = '×';
        taskEl.appendChild(delBtn);
        canvas.appendChild(taskEl);
        // Prevent drag start when pressing delete button
        delBtn.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
        });
        // Delete task on delete button click
        delBtn.addEventListener('click', () => {
          tasks.splice(index, 1);
          lastDeleted = { task: task, index: index };
          undoBtn.disabled = false;
          localStorage.setItem('tasks', JSON.stringify(tasks));
          renderTasks();
        });
        // Pointer events for dragging tasks
        taskEl.addEventListener('pointerdown', (e) => {
          if (e.button !== undefined && e.button !== 0) return;
          draggingTask = taskEl;
          pointerId = e.pointerId;
          dragging = false;
          startX = e.clientX + window.scrollX;
          startY = e.clientY + window.scrollY;
          dragOffsetX = startX - task.x;
          dragOffsetY = startY - task.y;
          // Bring this task to top by updating z-index
          taskEl.style.zIndex = Date.now();
          taskEl.setPointerCapture(pointerId);
          e.preventDefault();
        });
        taskEl.addEventListener('pointermove', (e) => {
          if (e.pointerId !== pointerId) return;
          const currentX = e.clientX + window.scrollX;
          const currentY = e.clientY + window.scrollY;
          const dx = currentX - startX;
          const dy = currentY - startY;
          if (!dragging && Math.abs(dx) < 5 && Math.abs(dy) < 5) {
            return;
          }
          dragging = true;
          let newLeft = currentX - dragOffsetX;
          let newTop = currentY - dragOffsetY;
          const canvasRect = { width: canvas.offsetWidth, height: canvas.offsetHeight };
          const elWidth = taskEl.offsetWidth;
          const elHeight = taskEl.offsetHeight;
          if (newLeft < 0) newLeft = 0;
          if (newTop < 0) newTop = 0;
          if (newLeft + elWidth > canvasRect.width) {
            newLeft = canvasRect.width - elWidth;
          }
          if (newTop + elHeight > canvasRect.height) {
            newTop = canvasRect.height - elHeight;
          }
          taskEl.style.left = newLeft + 'px';
          taskEl.style.top = newTop + 'px';
          // Prevent scrolling while dragging
          e.preventDefault();
        });
        taskEl.addEventListener('pointerup', (e) => {
          if (e.pointerId !== pointerId) return;
          taskEl.releasePointerCapture(pointerId);
          pointerId = null;
          if (dragging) {
            const newX = parseInt(taskEl.style.left);
            const newY = parseInt(taskEl.style.top);
            task.x = newX;
            task.y = newY;
            localStorage.setItem('tasks', JSON.stringify(tasks));
          } else {
            // Click without drag: toggle note
            task.expanded = !task.expanded;
            if (task.expanded) {
              taskEl.classList.add('expanded');
            } else {
              taskEl.classList.remove('expanded');
            }
            localStorage.setItem('tasks', JSON.stringify(tasks));
            const arrow = taskEl.querySelector('.arrow');
            if (arrow) {
              arrow.textContent = task.expanded ? '▼' : '▶';
            }
          }
          draggingTask = null;
          dragging = false;
        });
        taskEl.addEventListener('pointercancel', (e) => {
          if (e.pointerId !== pointerId) return;
          taskEl.releasePointerCapture(pointerId);
          pointerId = null;
          if (dragging) {
            task.x = parseInt(taskEl.style.left);
            task.y = parseInt(taskEl.style.top);
            localStorage.setItem('tasks', JSON.stringify(tasks));
          }
          draggingTask = null;
          dragging = false;
        });
      });
    }
    // Add new task
    addBtn.onclick = () => {
      const title = taskTitleInput.value.trim();
      const note = taskNoteInput.value.trim();
      if (!title) return;
      let newX = 10, newY = 10;
      if (tasks.length > 0) {
        const taskElements = document.querySelectorAll('.task');
        const existing = [];
        taskElements.forEach(el => {
          existing.push({
            x: parseInt(el.style.left),
            y: parseInt(el.style.top),
            width: el.offsetWidth,
            height: el.offsetHeight
          });
        });
        const estWidth = 160, estHeight = 100;
        outer: for (let y = 10; y < 500; y += 20) {
          for (let x = 10; x < 500; x += 20) {
            let overlap = false;
            for (const t of existing) {
              if (x < t.x + t.width &&
                  x + estWidth > t.x &&
                  y < t.y + t.height &&
                  y + estHeight > t.y) {
                overlap = true;
                break;
              }
            }
            if (!overlap) {
              newX = x;
              newY = y;
              break outer;
            }
          }
        }
      }
      const newTask = { title: title, note: note, x: newX, y: newY, expanded: false };
      tasks.push(newTask);
      localStorage.setItem('tasks', JSON.stringify(tasks));
      taskTitleInput.value = '';
      taskNoteInput.value = '';
      addBtn.disabled = true;
      renderTasks();
    };
    // Undo delete
    undoBtn.onclick = () => {
      if (lastDeleted) {
        tasks.splice(lastDeleted.index, 0, lastDeleted.task);
        lastDeleted = null;
        undoBtn.disabled = true;
        localStorage.setItem('tasks', JSON.stringify(tasks));
        renderTasks();
      }
    };
    // Export tasks to clipboard
    exportBtn.onclick = () => {
      const data = JSON.stringify(tasks);
      navigator.clipboard.writeText(data).then(() => {
        alert('任务数据已复制到剪贴板');
      }).catch(err => {
        alert('无法复制到剪贴板: ' + err);
      });
    };
    // Import tasks from clipboard
    importBtn.onclick = async () => {
      try {
        if (tasks.length > 0) {
          if (!confirm('导入操作将覆盖当前任务列表，确定继续？')) {
            return;
          }
        }
        const text = await navigator.clipboard.readText();
        if (!text) {
          alert('剪贴板为空');
          return;
        }
        const imported = JSON.parse(text);
        if (Array.isArray(imported)) {
          if (imported.length > 0 && typeof imported[0] === 'string') {
            tasks = imported.map((t, i) => ({
              title: t,
              note: '',
              x: 10,
              y: 10 + i * 60,
              expanded: false
            }));
          } else {
            tasks = imported.map(obj => ({
              title: String(obj.title || ''),
              note: String(obj.note || ''),
              x: typeof obj.x === 'number' ? obj.x : 10,
              y: typeof obj.y === 'number' ? obj.y : 10,
              expanded: !!obj.expanded
            }));
          }
          lastDeleted = null;
          undoBtn.disabled = true;
          localStorage.setItem('tasks', JSON.stringify(tasks));
          renderTasks();
        } else {
          alert('剪贴板数据格式不正确');
        }
      } catch (err) {
        alert('导入失败: ' + err);
      }
    };
    // Canvas background panning
    canvas.addEventListener('pointerdown', (e) => {
      if (e.target !== canvas) return;
      if (e.button !== undefined && e.button !== 0) return;
      panning = true;
      lastClientX = e.clientX;
      lastClientY = e.clientY;
      canvas.setPointerCapture(e.pointerId);
      e.preventDefault();
    });
    canvas.addEventListener('pointermove', (e) => {
      if (!panning) return;
      const dx = lastClientX - e.clientX;
      const dy = lastClientY - e.clientY;
      if (dx !== 0 || dy !== 0) {
        window.scrollBy(dx, dy);
        lastClientX = e.clientX;
        lastClientY = e.clientY;
      }
    });
    canvas.addEventListener('pointerup', (e) => {
      if (!panning) return;
      canvas.releasePointerCapture(e.pointerId);
      panning = false;
    });
    canvas.addEventListener('pointercancel', (e) => {
      if (!panning) return;
      canvas.releasePointerCapture(e.pointerId);
      panning = false;
    });
    // Initialize tasks from localStorage and adjust canvas margin
    window.addEventListener('DOMContentLoaded', () => {
      const stored = localStorage.getItem('tasks');
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) {
            if (parsed.length > 0 && typeof parsed[0] === 'string') {
              tasks = parsed.map((t, i) => ({
                title: t,
                note: '',
                x: 10,
                y: 10 + i * 60,
                expanded: false
              }));
            } else {
              tasks = parsed.map(obj => ({
                title: String(obj.title || ''),
                note: String(obj.note || ''),
                x: typeof obj.x === 'number' ? obj.x : 10,
                y: typeof obj.y === 'number' ? obj.y : 10,
                expanded: !!obj.expanded
              }));
            }
          }
        } catch (e) {
          console.error('Failed to parse tasks from localStorage');
        }
      }
      renderTasks();
      // Adjust canvas top margin to accommodate fixed header
      const topBar = document.getElementById('top-bar');
      canvas.style.marginTop = topBar.offsetHeight + 'px';
      window.addEventListener('resize', () => {
        canvas.style.marginTop = topBar.offsetHeight + 'px';
      });
    });
    // Register service worker for PWA
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
  </script>
</body>
</html>
