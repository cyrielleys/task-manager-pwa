<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Task PWA</title>
<style>
    /* 基础样式：取消默认内边距和边距，统一字体 */
    html, body {
        margin: 0;
        padding: 0;
        font-size: 12px;
        font-family: sans-serif;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }
    body.dragging {
        user-select: none;
    }
    /* 顶部控制区域样式 */
    #controls {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        background: #fff;
        border-bottom: 1px solid #ccc;
    }
    #controls .row {
        display: flex;
        align-items: center;
        padding: 4px;
    }
    #controls .row input[type="text"] {
        flex: 1;
        padding: 2px 4px;
        font-size: 12px;
        box-sizing: border-box;
    }
    #controls .buttons-row {
        justify-content: center;
    }
    #controls .buttons-row button {
        font-size: 12px;
        padding: 2px 6px;
        margin: 0 4px;
        cursor: pointer;
    }
    /* 任务画布容器样式 */
    #canvasWrap {
        position: absolute;
        left: 0;
        width: 100%;
        overflow: auto;
        -ms-overflow-style: none;
        scrollbar-width: none;
        touch-action: pan-x pan-y;
    }
    #canvasWrap::-webkit-scrollbar {
        display: none;
    }
    /* 实际任务画布 */
    #canvas {
        position: relative;
        width: 1560px;
        height: 1800px;
        background: #f5f5f5;
    }
    /* 单个任务元素样式 */
    .task {
        position: absolute;
        border: 1px solid #666;
        background: #f9f9f9;
        border-radius: 4px;
        padding: 4px 20px 4px 16px;
        color: #000;
        max-width: 300px;
        word-wrap: break-word;
        touch-action: none;
    }
    .task .task-title {
        font-weight: bold;
    }
    .task .task-note {
        margin-top: 4px;
        white-space: pre-wrap;
        display: none;
    }
    .task.expanded .task-note {
        display: block;
    }
    .task .toggle-btn {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #ccc;
        display: inline-block;
        vertical-align: middle;
        margin-right: 4px;
        cursor: pointer;
        padding: 0;
        outline: none;
        box-sizing: border-box;
        border: 1px solid #333;
    }
    .task .toggle-btn.expanded {
        background: #333;
    }
    .task .toggle-btn:hover {
        background: #bbb;
    }
    .task .toggle-btn.expanded:hover {
        background: #555;
    }
    .task .delete-btn {
        position: absolute;
        top: 2px;
        right: 2px;
        width: 14px;
        height: 14px;
        line-height: 12px;
        font-size: 12px;
        text-align: center;
        color: #333;
        background: #eee;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
        outline: none;
    }
    .task .delete-btn:hover {
        background: #e1e1e1;
    }
</style>
</head>
<body>
<!-- 顶部固定控制区域 -->
<div id="controls">
    <div class="row">
        <input type="text" id="titleInput" placeholder="任务标题">
    </div>
    <div class="row">
        <input type="text" id="noteInput" placeholder="备注">
    </div>
    <div class="row buttons-row">
        <button id="addBtn">添加</button>
        <button id="exportBtn">导出</button>
        <button id="importBtn">导入</button>
        <button id="undoBtn" disabled>撤销删除</button>
    </div>
</div>

<!-- 画布容器 -->
<div id="canvasWrap">
    <div id="canvas"></div>
</div>

<script>
    // 获取主要元素
    const canvasWrap = document.getElementById('canvasWrap');
    const canvas = document.getElementById('canvas');
    const titleInput = document.getElementById('titleInput');
    const noteInput = document.getElementById('noteInput');
    const addBtn = document.getElementById('addBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const undoBtn = document.getElementById('undoBtn');

    let tasks = [];
    let undoStack = []; // 最多保存10步删除记录
    let draggingTask = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let dragTaskWidth = 0, dragTaskHeight = 0;
    let dragStartTime = 0;

    let panning = false;
    let panStartX = 0, panStartY = 0;
    let startScrollLeft = 0, startScrollTop = 0;
    let maxScrollLeft = 0, maxScrollTop = 0;

    function adjustCanvasWrapHeight() {
        const controlsHeight = document.getElementById('controls').offsetHeight;
        canvasWrap.style.top = controlsHeight + 'px';
        canvasWrap.style.height = (window.innerHeight - controlsHeight) + 'px';
    }

    adjustCanvasWrapHeight();
    window.addEventListener('resize', adjustCanvasWrapHeight);

    const savedTasks = localStorage.getItem('tasks');
    if (savedTasks) {
        try {
            tasks = JSON.parse(savedTasks);
        } catch (e) {
            tasks = [];
        }
    }

    function renderTasks() {
        canvas.innerHTML = '';
        for (const task of tasks) {
            createTaskElement(task);
        }
    }

    function createTaskElement(task) {
        const taskElem = document.createElement('div');
        taskElem.className = 'task';
        taskElem.style.left = task.x + 'px';
        taskElem.style.top = task.y + 'px';
        taskElem.dataset.id = task.id;

        if (task.note && task.note.trim() !== '') {
            const toggleBtnElem = document.createElement('button');
            toggleBtnElem.type = 'button';
            toggleBtnElem.className = 'toggle-btn';
            toggleBtnElem.addEventListener('click', function(e) {
                e.stopPropagation();
                const taskEl = this.parentElement;
                if (taskEl.classList.contains('expanded')) {
                    taskEl.classList.remove('expanded');
                    this.classList.remove('expanded');
                } else {
                    taskEl.classList.add('expanded');
                    this.classList.add('expanded');
                }
            });
            taskElem.appendChild(toggleBtnElem);
        }

        const titleElem = document.createElement('span');
        titleElem.className = 'task-title';
        titleElem.textContent = task.title;
        taskElem.appendChild(titleElem);

        if (task.note && task.note.trim() !== '') {
            const noteElem = document.createElement('div');
            noteElem.className = 'task-note';
            noteElem.textContent = task.note;
            taskElem.appendChild(noteElem);
        }

        const deleteBtnElem = document.createElement('button');
        deleteBtnElem.type = 'button';
        deleteBtnElem.className = 'delete-btn';
        deleteBtnElem.textContent = '×';
        deleteBtnElem.addEventListener('click', function(e) {
            e.stopPropagation();
            const taskEl = this.parentElement;
            const taskId = taskEl.dataset.id;
            const index = tasks.findIndex(t => String(t.id) === String(taskId));
            if (index !== -1) {
                undoStack.push(tasks[index]);
                if (undoStack.length > 10) {
                    undoStack.shift();
                }
                tasks.splice(index, 1);
                canvas.removeChild(taskEl);
                saveTasks();
                undoBtn.disabled = false;
            }
        });
        taskElem.appendChild(deleteBtnElem);

        taskElem.addEventListener('pointerdown', function(e) {
            e.stopPropagation();
            if (draggingTask || panning) return;
            draggingTask = this;
            dragTaskWidth = draggingTask.offsetWidth;
            dragTaskHeight = draggingTask.offsetHeight;
            const canvasRect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - canvasRect.left;
            const canvasY = e.clientY - canvasRect.top;
            dragOffsetX = canvasX - draggingTask.offsetLeft;
            dragOffsetY = canvasY - draggingTask.offsetTop;
            dragStartTime = Date.now();
            draggingTask.setPointerCapture(e.pointerId);
            document.body.classList.add('dragging');
        });

        taskElem.addEventListener('pointermove', function(e) {
            if (!draggingTask || draggingTask !== this) return;
            if (Date.now() - dragStartTime < 150) return; // 避免点击误触发拖动
            e.preventDefault();

            const canvasRect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - canvasRect.left;
            const canvasY = e.clientY - canvasRect.top;

            let newLeft = canvasX - dragOffsetX;
            let newTop = canvasY - dragOffsetY;

            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;

            const maxLeft = canvas.offsetWidth - dragTaskWidth;
            const maxTop = canvas.offsetHeight - dragTaskHeight;

            if (newLeft > maxLeft) newLeft = maxLeft;
            if (newTop > maxTop) newTop = maxTop;

            draggingTask.style.left = newLeft + 'px';
            draggingTask.style.top = newTop + 'px';
        });

        taskElem.addEventListener('pointerup', function(e) {
            if (!draggingTask || draggingTask !== this) return;
            draggingTask = null;
            document.body.classList.remove('dragging');
            const taskId = this.dataset.id;
            const taskObj = tasks.find(t => String(t.id) === String(taskId));
            if (taskObj) {
                taskObj.x = parseFloat(this.style.left);
                taskObj.y = parseFloat(this.style.top);
                saveTasks();
            }
        });

        taskElem.addEventListener('pointercancel', function(e) {
            if (!draggingTask || draggingTask !== this) return;
            draggingTask = null;
            document.body.classList.remove('dragging');
            const taskId = this.dataset.id;
            const taskObj = tasks.find(t => String(t.id) === String(taskId));
            if (taskObj) {
                taskObj.x = parseFloat(this.style.left);
                taskObj.y = parseFloat(this.style.top);
                saveTasks();
            }
        });

        canvas.appendChild(taskElem);
    }

    function saveTasks() {
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }

    renderTasks();

    addBtn.addEventListener('click', function() {
        const title = titleInput.value.trim();
        const note = noteInput.value.trim();
        if (!title) return;

        let newId = 1;
        if (tasks.length > 0) {
            const maxId = tasks.reduce((max, t) => {
                const idNum = typeof t.id === 'number' ? t.id : parseInt(t.id) || 0;
                return idNum > max ? idNum : max;
            }, 0);
            newId = maxId + 1;
        }

        const newTask = {
            id: newId,
            title: title,
            note: note,
            x: 20 + tasks.length * 10,
            y: 20 + tasks.length * 10
        };

        tasks.push(newTask);
        createTaskElement(newTask);
        saveTasks();
        titleInput.value = '';
        noteInput.value = '';
    });

    undoBtn.addEventListener('click', function () {
        if (undoStack.length === 0) return;
        const taskToRestore = undoStack.pop();
        tasks.push(taskToRestore);
        renderTasks();
        saveTasks();
        if (undoStack.length === 0) {
            undoBtn.disabled = true;
        }
    });

    exportBtn.addEventListener('click', function() {
        const jsonStr = JSON.stringify(tasks, null, 2);
        navigator.clipboard.writeText(jsonStr).then(() => {
            alert('任务数据已复制到剪贴板！');
        }).catch(err => {
            alert('导出失败：' + err);
        });
    });

    importBtn.addEventListener('click', function() {
        navigator.clipboard.readText().then(text => {
            if (!text) {
                alert('剪贴板没有内容！');
                return;
            }
            try {
                const data = JSON.parse(text);
                if (!Array.isArray(data)) throw new Error('数据格式不正确');
                tasks = data;
                renderTasks();
                saveTasks();
                undoStack = [];
                undoBtn.disabled = true;
                alert('任务数据已从剪贴板导入并加载！');
            } catch (err) {
                alert('导入失败：剪贴板内容不是有效的任务JSON数据');
            }
        }).catch(err => {
            alert('无法读取剪贴板：' + err);
        });
    });

    canvasWrap.addEventListener('pointerdown', function(e) {
        if (draggingTask || panning) return;
        if (e.pointerType !== 'mouse') return;
        panning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        startScrollLeft = canvasWrap.scrollLeft;
        startScrollTop = canvasWrap.scrollTop;
        maxScrollLeft = canvas.scrollWidth - canvasWrap.clientWidth;
        maxScrollTop = canvas.scrollHeight - canvasWrap.clientHeight;
        canvasWrap.setPointerCapture(e.pointerId);
        document.body.classList.add('dragging');
    });

    canvasWrap.addEventListener('pointermove', function(e) {
        if (!panning) return;
        e.preventDefault();
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        canvasWrap.scrollLeft = Math.max(0, Math.min(maxScrollLeft, startScrollLeft - dx));
        canvasWrap.scrollTop = Math.max(0, Math.min(maxScrollTop, startScrollTop - dy));
    });

    canvasWrap.addEventListener('pointerup', function(e) {
        if (!panning) return;
        panning = false;
        document.body.classList.remove('dragging');
    });

    canvasWrap.addEventListener('pointercancel', function(e) {
        if (!panning) return;
        panning = false;
        document.body.classList.remove('dragging');
    });
</script>
</body>
</html>
