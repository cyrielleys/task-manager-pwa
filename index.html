<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Task Board</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
  margin: 0;
  color: #fff;
  /* Dark theme background: black and grey checkerboard pattern */
  background: #000;
}
#topbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #000;
  z-index: 1000;
  padding: 5px;
}
#topbar .row {
  margin-bottom: 5px;
}
#topbar .row:last-child {
  margin-bottom: 0;
}
#topbar input, #topbar button, #topbar textarea {
  box-sizing: border-box;
  font: inherit;
}
#titleInput, #noteInput {
  width: 100%;
  padding: 5px;
  margin: 0;
  background: #333;
  border: 1px solid #555;
  color: #fff;
}
#noteInput {
  resize: none;
}
#buttonsRow {
  text-align: center;
}
#buttonsRow button {
  background: #333;
  color: #fff;
  border: 1px solid #555;
  padding: 5px 10px;
  margin: 0 5px;
  cursor: pointer;
}
#buttonsRow button:hover {
  background: #444;
}
#buttonsRow button:active {
  background: #555;
}
#board {
  position: relative;
  width: 3000px;
  height: 2000px;
  /* Checkerboard background: black and 90% gray squares */
  background-color: #000;
  background-image: repeating-conic-gradient(transparent 0deg 90deg, #e6e6e6 0deg 180deg);
  background-size: 33.33vw 33.33vw;
  background-position: 0 0;
  cursor: grab;
}
.task {
  position: absolute;
  display: inline-block;
  background: #333;
  color: #fff;
  border: 1px solid #555;
  border-radius: 4px;
  padding: 5px;
  min-width: 6ch;
  word-wrap: break-word;
  overflow-wrap: break-word;
  cursor: pointer;
}
.task .task-title {
  white-space: nowrap;
}
.task .task-note {
  display: none;
  margin-top: 5px;
  font-size: 0.9em;
  line-height: 1.2em;
  white-space: pre-wrap;
}
.task.expanded .task-note {
  display: block;
}
.task .expand-btn, .task .delete-btn {
  position: absolute;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  top: 5px;
  cursor: pointer;
}
.task .expand-btn {
  left: 5px;
  background: #00f;
}
.task .delete-btn {
  right: 5px;
  background: #f00;
}
.task.selected {
  border: 2px solid #fff;
}
</style>
</head>
<body>
<div id="topbar">
  <div class="row"><input id="titleInput" type="text" placeholder="标题"></div>
  <div class="row"><textarea id="noteInput" placeholder="备注"></textarea></div>
  <div class="row" id="buttonsRow">
    <button id="addBtn">添加任务</button>
    <button id="importBtn">导入</button>
    <button id="exportBtn">导出</button>
    <button id="undoBtn">撤销</button>
  </div>
</div>
<div id="board"></div>
<script>
(() => {
  const board = document.getElementById('board');
  const titleInput = document.getElementById('titleInput');
  const noteInput = document.getElementById('noteInput');
  const addBtn = document.getElementById('addBtn');
  const importBtn = document.getElementById('importBtn');
  const exportBtn = document.getElementById('exportBtn');
  const undoBtn = document.getElementById('undoBtn');

  let selectedTask = null;
  let undoStack = [];
  let zCounter = 0;

  function selectTask(task) {
    if (selectedTask && selectedTask !== task) {
      selectedTask.classList.remove('selected');
    }
    selectedTask = task;
    if (task) {
      task.classList.add('selected');
      // Bring to front
      zCounter++;
      task.style.zIndex = zCounter;
    }
  }

  function deselectAll() {
    if (selectedTask) {
      selectedTask.classList.remove('selected');
      selectedTask = null;
    }
  }

  function createTaskElement(data) {
    // Create task elements
    const taskEl = document.createElement('div');
    taskEl.className = 'task';
    const expandBtn = document.createElement('div');
    expandBtn.className = 'expand-btn';
    const deleteBtn = document.createElement('div');
    deleteBtn.className = 'delete-btn';
    const titleDiv = document.createElement('div');
    titleDiv.className = 'task-title';
    const noteDiv = document.createElement('div');
    noteDiv.className = 'task-note';
    titleDiv.textContent = data.title;
    noteDiv.textContent = data.note;
    taskEl.appendChild(expandBtn);
    taskEl.appendChild(deleteBtn);
    taskEl.appendChild(titleDiv);
    taskEl.appendChild(noteDiv);
    // Position
    taskEl.style.left = data.x + 'px';
    taskEl.style.top = data.y + 'px';
    // Set initial expanded state
    if (data.expanded) {
      taskEl.classList.add('expanded');
    }
    // Hide expand button if no note content
    if (!data.note) {
      expandBtn.style.display = 'none';
    }
    // Assign an initial z-index and bring to front
    zCounter++;
    taskEl.style.zIndex = zCounter;

    // Event: expand/collapse notes
    expandBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (taskEl.classList.contains('expanded')) {
        taskEl.classList.remove('expanded');
      } else {
        taskEl.classList.add('expanded');
      }
    });
    // Prevent parent events if clicking the expand or delete button
    expandBtn.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
    });
    deleteBtn.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
    });
    // Event: delete task
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Remove from DOM and save for undo
      const taskData = {
        title: data.title,
        note: data.note,
        x: parseFloat(taskEl.style.left) || 0,
        y: parseFloat(taskEl.style.top) || 0,
        expanded: taskEl.classList.contains('expanded')
      };
      // Deselect if this was selected
      if (selectedTask === taskEl) {
        selectedTask = null;
      }
      board.removeChild(taskEl);
      undoStack.push(taskData);
    });
    // Event: pointer down (for selection and possible drag)
    taskEl.addEventListener('pointerdown', (e) => {
      // Only handle primary mouse button
      if (e.button !== 0) return;
      e.stopPropagation();
      selectTask(taskEl);
      // Prepare for drag
      taskEl.setPointerCapture(e.pointerId);
      let dragging = false;
      let allowDrag = false;
      let startX = e.clientX;
      let startY = e.clientY;
      let elemX = parseFloat(taskEl.style.left) || 0;
      let elemY = parseFloat(taskEl.style.top) || 0;
      // Start long-press timer
      const pressTimer = setTimeout(() => {
        allowDrag = true;
      }, 300);
      // Pointer move
      taskEl.addEventListener('pointermove', onPointerMove);
      taskEl.addEventListener('pointerup', onPointerUp);

      function onPointerMove(ev) {
        if (!dragging) {
          // If not yet started dragging, check conditions
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          if (!allowDrag) {
            // If movement surpasses threshold before timer
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
              allowDrag = true;
              clearTimeout(pressTimer);
            }
          }
          if (allowDrag) {
            dragging = true;
            taskEl.style.cursor = 'grabbing';
            document.body.style.userSelect = 'none';
          } else {
            return; // not allowed to drag yet
          }
        }
        // If dragging
        let newX = elemX + (ev.clientX - startX);
        let newY = elemY + (ev.clientY - startY);
        // Constrain within board
        if (newX < 0) newX = 0;
        if (newY < 0) newY = 0;
        const maxX = board.clientWidth - taskEl.clientWidth;
        const maxY = board.clientHeight - taskEl.clientHeight;
        if (newX > maxX) newX = maxX;
        if (newY > maxY) newY = maxY;
        taskEl.style.left = newX + 'px';
        taskEl.style.top = newY + 'px';
      }

      function onPointerUp(ev) {
        clearTimeout(pressTimer);
        // Remove move/up listeners
        taskEl.removeEventListener('pointermove', onPointerMove);
        taskEl.removeEventListener('pointerup', onPointerUp);
        taskEl.releasePointerCapture(ev.pointerId);
        // Reset styles
        document.body.style.userSelect = '';
        taskEl.style.cursor = '';
        dragging = false;
      }
    });
    // Append to board
    board.appendChild(taskEl);
  }

  // Board background dragging (desktop)
  let draggingBoard = false;
  let boardStartX, boardStartY;
  let scrollStartLeft, scrollStartTop;
  board.addEventListener('pointerdown', (e) => {
    if (e.target !== board) return;
    // Only allow dragging with mouse or pen (touch uses native scroll)
    if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
      e.preventDefault();
      board.setPointerCapture(e.pointerId);
      draggingBoard = true;
      boardStartX = e.clientX;
      boardStartY = e.clientY;
      scrollStartLeft = window.scrollX;
      scrollStartTop = window.scrollY;
      board.style.cursor = 'grabbing';
      document.body.style.userSelect = 'none';
    }
    // Deselect if clicking empty space
    deselectAll();
  });
  board.addEventListener('pointermove', (e) => {
    if (!draggingBoard) return;
    const dx = e.clientX - boardStartX;
    const dy = e.clientY - boardStartY;
    window.scrollTo(scrollStartLeft - dx, scrollStartTop - dy);
  });
  board.addEventListener('pointerup', (e) => {
    if (!draggingBoard) return;
    board.releasePointerCapture(e.pointerId);
    draggingBoard = false;
    board.style.cursor = 'grab';
    document.body.style.userSelect = '';
  });

  // Add task
  addBtn.addEventListener('click', () => {
    const title = titleInput.value.trim();
    const note = noteInput.value;
    if (!title) {
      alert('标题不能为空！');
      return;
    }
    // Determine position near current viewport
    const px = window.scrollX;
    const py = window.scrollY;
    let newX = px + 100;
    let newY = py + 100;
    // Clamp within board
    const maxX = board.clientWidth - 300;
    const maxY = board.clientHeight - 100;
    if (newX > maxX) newX = board.clientWidth - 100;
    if (newY > maxY) newY = board.clientHeight - 100;
    const data = { title: title, note: note, x: newX, y: newY, expanded: false };
    createTaskElement(data);
    // Clear inputs
    titleInput.value = '';
    noteInput.value = '';
  });

  // Export tasks to JSON
  exportBtn.addEventListener('click', () => {
    const tasks = document.querySelectorAll('.task');
    const data = [];
    tasks.forEach(taskEl => {
      data.push({
        title: taskEl.querySelector('.task-title').textContent,
        note: taskEl.querySelector('.task-note').textContent,
        x: parseFloat(taskEl.style.left) || 0,
        y: parseFloat(taskEl.style.top) || 0,
        expanded: taskEl.classList.contains('expanded')
      });
    });
    const json = JSON.stringify(data);
    navigator.clipboard.writeText(json).then(() => {
      alert('任务已导出到剪贴板！');
    }).catch(err => {
      alert('导出失败：' + err);
    });
  });

  // Import tasks from JSON
  importBtn.addEventListener('click', () => {
    navigator.clipboard.readText().then(text => {
      if (!text) {
        alert('剪贴板没有任务数据！');
        return;
      }
      let arr;
      try {
        arr = JSON.parse(text);
      } catch (err) {
        alert('导入失败：剪贴板内容不是有效的JSON！');
        return;
      }
      if (!Array.isArray(arr)) {
        alert('导入失败：数据格式不正确！');
        return;
      }
      // Clear existing tasks
      const existing = document.querySelectorAll('.task');
      existing.forEach(t => board.removeChild(t));
      selectedTask = null;
      undoStack = [];
      zCounter = 0;
      // Add each imported task
      arr.forEach(item => {
        const data = {
          title: item.title || '',
          note: item.note || '',
          x: item.x || 0,
          y: item.y || 0,
          expanded: !!item.expanded
        };
        createTaskElement(data);
      });
      alert('导入成功！');
    }).catch(err => {
      alert('无法读取剪贴板：' + err);
    });
  });

  // Undo delete
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) {
      return;
    }
    const data = undoStack.pop();
    createTaskElement(data);
  });

  // Adjust board position margin to avoid topbar overlap
  function adjustBoardMargin() {
    const topbar = document.getElementById('topbar');
    const topbarHeight = topbar.offsetHeight;
    board.style.marginTop = topbarHeight + 'px';
  }
  // Initial adjust and on resize
  adjustBoardMargin();
  window.addEventListener('resize', adjustBoardMargin);
})();
</script>
</body>
</html>
