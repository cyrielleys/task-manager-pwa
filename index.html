<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>任务管理</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      background: #fff;
    }
    * {
      box-sizing: border-box;
    }
    /* 顶部固定输入栏样式 */
    #topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #f0f0f0;
      border-bottom: 1px solid #ccc;
      padding: 5px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      z-index: 1000;
    }
    #topbar input {
      height: 30px;
      line-height: 30px;
      padding: 0 6px;
      margin-right: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    #topbar input#noteInput {
      width: 200px;
    }
    #topbar input#titleInput {
      width: 150px;
    }
    #topbar button {
      height: 30px;
      line-height: 30px;
      padding: 0 10px;
      margin-right: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #eee;
      font-size: 14px;
      cursor: pointer;
    }
    #topbar button:hover:enabled {
      background: #ddd;
    }
    #topbar button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    /* 画布容器样式 */
    #canvas {
      position: absolute;
      top: 50px; /* 顶部栏高度 */
      bottom: 0;
      left: 0;
      right: 0;
      overflow: hidden;
      background: #fafafa;
    }
    /* 任务画布（内部可拖动区域）样式 */
    #board {
      position: absolute;
      top: 0;
      left: 0;
      width: 3000px;
      height: 2000px;
      min-width: 100%;
      min-height: 100%;
      /* 使用 transform 平移整个画布实现拖动 */
      touch-action: none; /* 禁用触摸默认滚动行为，确保移动平滑 */
      user-select: none;
      -webkit-user-select: none;
    }
    /* 任务卡片样式 */
    .task {
      position: absolute;
      min-width: 100px;
      max-width: 200px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #ffffe0; /* 浅黄色背景 */
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
    }
    .task .title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 4px;
    }
    .task .note {
      font-size: 13px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .task .delete-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      line-height: 14px;
      text-align: center;
      border: none;
      background: #ccc;
      color: #333;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      padding: 0;
    }
    .task .delete-btn:hover {
      background: #aaa;
    }
  </style>
</head>
<body>
  <!-- 顶部输入栏：任务标题和备注输入框，以及操作按钮 -->
  <div id="topbar">
    <input type="text" id="titleInput" placeholder="任务标题">
    <input type="text" id="noteInput" placeholder="备注">
    <button id="addBtn">添加任务</button>
    <button id="undoBtn">撤销删除</button>
    <button id="importBtn">导入任务</button>
    <button id="exportBtn">导出任务</button>
  </div>
  <!-- 画布区域 -->
  <div id="canvas">
    <div id="board"></div>
  </div>
  <!-- 文件选择输入，用于导入任务 -->
  <input type="file" id="fileInput" accept=".json" style="display: none;">
  
  <script>
    // 全局数据结构
    const tasksData = [];  // 存储任务的数组，每项包含{id, title, note, x, y, width, height, element}
    let nextTaskId = 1;
    const deletedStack = []; // 删除任务栈，用于撤销删除
    // 拖拽相关状态
    let offsetX = 0, offsetY = 0; // 画布平移偏移
    let isDraggingBoard = false;
    let draggingTaskElem = null;
    let dragTaskData = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let lastPointerX = 0, lastPointerY = 0;
    let activePointerId = null;
    
    // 获取主要DOM元素
    const titleInput = document.getElementById('titleInput');
    const noteInput = document.getElementById('noteInput');
    const addBtn = document.getElementById('addBtn');
    const undoBtn = document.getElementById('undoBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const fileInput = document.getElementById('fileInput');
    const board = document.getElementById('board');
    const canvas = document.getElementById('canvas');
    
    // 初始化撤销删除按钮为禁用
    undoBtn.disabled = true;
    
    // 计算画布有效宽高（考虑固定大小和当前可视区域）
    function getBoardWidth() {
      return Math.max(board.offsetWidth, canvas.clientWidth);
    }
    function getBoardHeight() {
      return Math.max(board.offsetHeight, canvas.clientHeight);
    }
    
    // 查找新任务卡片可放置的空闲位置（避免与现有任务重叠）
    function findFreePosition(newWidth, newHeight) {
      const gap = 10;
      const boardW = getBoardWidth();
      const boardH = getBoardHeight();
      for (let y = 0; y <= boardH - newHeight; y += 10) {
        for (let x = 0; x <= boardW - newWidth; x += 10) {
          let overlap = false;
          for (const task of tasksData) {
            if (!(x + newWidth + gap <= task.x || x >= task.x + task.width + gap ||
                  y + newHeight + gap <= task.y || y >= task.y + task.height + gap)) {
              overlap = true;
              break;
            }
          }
          if (!overlap) {
            return { x, y };
          }
        }
      }
      return { x: 0, y: 0 };
    }
    
    // 创建并添加一个任务元素到画布，返回其元素和尺寸
    function createTaskElement(id, title, note, x, y) {
      const taskElem = document.createElement('div');
      taskElem.className = 'task';
      taskElem.setAttribute('data-id', id);
      // 标题和备注内容
      const titleDiv = document.createElement('div');
      titleDiv.className = 'title';
      titleDiv.textContent = title;
      taskElem.appendChild(titleDiv);
      const noteDiv = document.createElement('div');
      noteDiv.className = 'note';
      noteDiv.textContent = note;
      taskElem.appendChild(noteDiv);
      // 删除按钮
      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = '×';
      taskElem.appendChild(delBtn);
      // 设置初始位置并插入到DOM（先隐藏测量尺寸）
      taskElem.style.left = x + 'px';
      taskElem.style.top = y + 'px';
      taskElem.style.visibility = 'hidden';
      board.appendChild(taskElem);
      // 测量元素尺寸
      const rect = taskElem.getBoundingClientRect();
      const taskWidth = rect.width;
      const taskHeight = rect.height;
      // 显示元素
      taskElem.style.visibility = 'visible';
      return { element: taskElem, width: taskWidth, height: taskHeight };
    }
    
    // 从输入框添加新任务
    function addTaskFromInput() {
      const title = titleInput.value.trim();
      const note = noteInput.value.trim();
      if (!title) {
        alert('请输入任务标题');
        return;
      }
      // 创建临时任务元素来获取其尺寸
      const temp = createTaskElement('temp', title, note, 0, 0);
      const w = temp.width;
      const h = temp.height;
      board.removeChild(temp.element);
      // 寻找空闲位置
      const pos = findFreePosition(w, h);
      const id = nextTaskId++;
      // 创建实际任务元素
      const task = createTaskElement(id, title, note, pos.x, pos.y);
      // 保存任务数据
      tasksData.push({ id: id, title: title, note: note, x: pos.x, y: pos.y, width: task.width, height: task.height, element: task.element });
      // 清空输入框
      titleInput.value = '';
      noteInput.value = '';
    }
    
    // 删除任务
    function deleteTask(taskElem) {
      const id = parseInt(taskElem.getAttribute('data-id'));
      const index = tasksData.findIndex(t => t.id === id);
      if (index !== -1) {
        const removed = tasksData.splice(index, 1)[0];
        board.removeChild(taskElem);
        deletedStack.push(removed);
        undoBtn.disabled = false;
      }
    }
    
    // 撤销删除任务
    function undoDelete() {
      if (deletedStack.length === 0) return;
      const taskData = deletedStack.pop();
      // 重新插入任务元素
      board.appendChild(taskData.element);
      taskData.element.style.left = taskData.x + 'px';
      taskData.element.style.top = taskData.y + 'px';
      // 恢复任务数据
      tasksData.push(taskData);
      if (deletedStack.length === 0) {
        undoBtn.disabled = true;
      }
    }
    
    // 导出任务列表为JSON文件
    function exportTasks() {
      const data = tasksData.map(t => ({ title: t.title, note: t.note, x: t.x, y: t.y }));
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // 导入任务列表
    function importTasks(taskList) {
      // 清除当前任务
      for (const task of tasksData) {
        if (task.element && task.element.parentNode) {
          board.removeChild(task.element);
        }
      }
      tasksData.length = 0;
      deletedStack.length = 0;
      undoBtn.disabled = true;
      nextTaskId = 1;
      // 添加导入的任务
      for (const item of taskList) {
        const title = item.title || '';
        const note = item.note || '';
        const x = item.x !== undefined ? item.x : 0;
        const y = item.y !== undefined ? item.y : 0;
        const id = nextTaskId++;
        const task = createTaskElement(id, title, note, x, y);
        tasksData.push({ id: id, title: title, note: note, x: x, y: y, width: task.width, height: task.height, element: task.element });
      }
      // 调整画布尺寸以容纳所有任务
      let maxX = 0, maxY = 0;
      for (const t of tasksData) {
        maxX = Math.max(maxX, t.x + t.width);
        maxY = Math.max(maxY, t.y + t.height);
      }
      const newW = Math.max(board.offsetWidth, canvas.clientWidth, maxX + 50);
      const newH = Math.max(board.offsetHeight, canvas.clientHeight, maxY + 50);
      board.style.width = newW + 'px';
      board.style.height = newH + 'px';
    }
    
    // 按钮事件绑定
    addBtn.addEventListener('click', addTaskFromInput);
    undoBtn.addEventListener('click', undoDelete);
    importBtn.addEventListener('click', () => {
      if (tasksData.length > 0) {
        if (!confirm('导入任务将替换当前任务列表，确定继续？')) {
          return;
        }
      }
      fileInput.value = '';
      fileInput.click();
    });
    exportBtn.addEventListener('click', exportTasks);
    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (Array.isArray(data)) {
            importTasks(data);
            alert(`已导入${data.length}个任务`);
          } else {
            alert('文件格式错误，导入失败');
          }
        } catch {
          alert('解析文件时出错，导入失败');
        }
      };
      reader.onerror = () => {
        alert('读取文件失败');
      };
      reader.readAsText(file);
    });
    
    // 画布和任务拖拽
    // 指针/鼠标按下
    function onPointerDown(e) {
      if (activePointerId !== null) return;
      activePointerId = (e.pointerId !== undefined ? e.pointerId : 'mouse');
      e.preventDefault();
      const taskElem = e.target.closest('.task');
      if (taskElem) {
        // 点击了任务卡片
        if (e.target.classList.contains('delete-btn')) {
          // 如果点击的是删除按钮，不启动拖拽
          activePointerId = null;
          return;
        }
        // 准备拖动任务
        draggingTaskElem = taskElem;
        const id = parseInt(taskElem.getAttribute('data-id'));
        dragTaskData = tasksData.find(t => t.id === id);
        // 计算指针与任务左上角的偏移
        const canvasRect = canvas.getBoundingClientRect();
        const pointerBoardX = e.clientX - canvasRect.left - offsetX;
        const pointerBoardY = e.clientY - canvasRect.top - offsetY;
        dragOffsetX = pointerBoardX - dragTaskData.x;
        dragOffsetY = pointerBoardY - dragTaskData.y;
        // 改变光标样式
        taskElem.style.cursor = 'grabbing';
      } else {
        // 准备拖动画布
        isDraggingBoard = true;
        lastPointerX = e.clientX;
        lastPointerY = e.clientY;
        board.style.cursor = 'grabbing';
      }
      // 捕获指针以跟踪拖拽
      if (window.PointerEvent && e.pointerId !== undefined) {
        board.setPointerCapture(e.pointerId);
      }
    }
    // 指针/鼠标移动
    function onPointerMove(e) {
      if (activePointerId === null) return;
      if (e.pointerId !== undefined && e.pointerId !== activePointerId) return;
      e.preventDefault();
      if (draggingTaskElem) {
        // 拖动任务元素
        const canvasRect = canvas.getBoundingClientRect();
        const pointerBoardX = e.clientX - canvasRect.left - offsetX;
        const pointerBoardY = e.clientY - canvasRect.top - offsetY;
        let newX = pointerBoardX - dragOffsetX;
        let newY = pointerBoardY - dragOffsetY;
        // 限制任务在画布内
        const boardW = getBoardWidth();
        const boardH = getBoardHeight();
        if (newX < 0) newX = 0;
        if (newY < 0) newY = 0;
        if (newX + dragTaskData.width > boardW) {
          newX = boardW - dragTaskData.width;
        }
        if (newY + dragTaskData.height > boardH) {
          newY = boardH - dragTaskData.height;
        }
        draggingTaskElem.style.left = newX + 'px';
        draggingTaskElem.style.top = newY + 'px';
        // 更新任务数据
        dragTaskData.x = newX;
        dragTaskData.y = newY;
      } else if (isDraggingBoard) {
        // 拖动整个画布
        const dx = e.clientX - lastPointerX;
        const dy = e.clientY - lastPointerY;
        lastPointerX = e.clientX;
        lastPointerY = e.clientY;
        offsetX += dx;
        offsetY += dy;
        board.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }
    }
    // 指针/鼠标释放
    function onPointerUp(e) {
      if (activePointerId === null) return;
      if (e.pointerId !== undefined && e.pointerId !== activePointerId) return;
      e.preventDefault();
      if (draggingTaskElem) {
        draggingTaskElem.style.cursor = 'grab';
      }
      if (isDraggingBoard) {
        board.style.cursor = 'grab';
      }
      // 释放指针捕获
      if (window.PointerEvent && e.pointerId !== undefined) {
        try { board.releasePointerCapture(e.pointerId); } catch {}
      }
      // 重置状态
      isDraggingBoard = false;
      draggingTaskElem = null;
      dragTaskData = null;
      activePointerId = null;
    }
    
    // 初始化光标样式
    board.style.cursor = 'grab';
    
    // 注册拖拽事件监听
    if (window.PointerEvent) {
      board.addEventListener('pointerdown', onPointerDown);
      board.addEventListener('pointermove', onPointerMove);
      board.addEventListener('pointerup', onPointerUp);
      board.addEventListener('pointercancel', onPointerUp);
    } else {
      // 鼠标事件
      board.addEventListener('mousedown', e => {
        onPointerDown(e);
        document.addEventListener('mousemove', onPointerMove);
        document.addEventListener('mouseup', onPointerUp);
      });
      // 触摸事件
      const onTouchMove = evt => {
        if (evt.touches.length > 0) {
          onPointerMove(evt.touches[0]);
        }
      };
      const onTouchEnd = evt => {
        onPointerUp(evt.changedTouches[0] || {});
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
        document.removeEventListener('touchcancel', onTouchEnd);
      };
      board.addEventListener('touchstart', e => {
        if (e.touches.length > 0) {
          onPointerDown(e.touches[0]);
          document.addEventListener('touchmove', onTouchMove);
          document.addEventListener('touchend', onTouchEnd);
          document.addEventListener('touchcancel', onTouchEnd);
        }
      });
    }
    
    // 删除按钮点击事件委托
    board.addEventListener('click', e => {
      if (e.target.classList.contains('delete-btn')) {
        const taskElem = e.target.closest('.task');
        if (taskElem) {
          deleteTask(taskElem);
        }
      }
    });
  </script>
</body>
</html>
