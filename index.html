<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Task Board</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f0f0f0;
    }
    #board {
      position: relative;
      width: 100%;
      height: 100vh; /* full viewport height as draggable area */
      background: #e0e0e0;
      overflow: hidden;
    }
    .card {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      font-size: 16px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      /* Prevent text selection and default touch actions while dragging */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: none;
      -webkit-touch-callout: none;
      cursor: grab;
      cursor: -webkit-grab;
    }
    .card:active {
      cursor: grabbing;
      cursor: -webkit-grabbing;
    }
  </style>
</head>
<body>
  <div id="board">
    <div class="card" id="task1">Task 1: This is an example task card. It can be dragged around.</div>
    <div class="card" id="task2">Task 2: Drag me with your finger on a touchscreen!</div>
    <div class="card" id="task3">Task 3: My position will be saved and restored after reload.</div>
  </div>
  <script>
    (function() {
      const board = document.getElementById('board');
      const cards = document.querySelectorAll('.card');
      let dragEl = null;
      let offsetX = 0, offsetY = 0, containerRect;
      let zCounter = 0;
      // Load saved card positions from localStorage
      const savedPositions = JSON.parse(localStorage.getItem('cardPositions') || '{}');
      cards.forEach((card, index) => {
        const id = card.id;
        if (savedPositions[id]) {
          // Apply saved position
          card.style.left = savedPositions[id].left + 'px';
          card.style.top = savedPositions[id].top + 'px';
        } else {
          // Set default initial positions (stacked vertically with spacing)
          card.style.left = '10px';
          card.style.top = (10 + index * 120) + 'px';
        }
      });
      // Handle drag end: save position and reset state
      function endDrag() {
        if (!dragEl) return;
        // Save final position in localStorage
        savedPositions[dragEl.id] = {
          left: parseInt(dragEl.style.left, 10),
          top: parseInt(dragEl.style.top, 10)
        };
        localStorage.setItem('cardPositions', JSON.stringify(savedPositions));
        dragEl = null;
      }
      // Add pointer event listeners for dragging
      cards.forEach(card => {
        card.addEventListener('pointerdown', e => {
          if (dragEl) return;  // already dragging another card
          dragEl = card;
          // Raise this card above others
          zCounter++;
          dragEl.style.zIndex = zCounter;
          // Calculate pointerâ€™s offset within the card
          containerRect = board.getBoundingClientRect();
          offsetX = e.clientX - containerRect.left - parseFloat(dragEl.style.left);
          offsetY = e.clientY - containerRect.top - parseFloat(dragEl.style.top);
          // Capture pointer events to this card
          dragEl.setPointerCapture(e.pointerId);
        });
        card.addEventListener('pointermove', e => {
          if (!dragEl || dragEl !== card) return;
          e.preventDefault();  // prevent page scrolling during drag
          // Compute new position
          let newLeft = e.clientX - containerRect.left - offsetX;
          let newTop  = e.clientY - containerRect.top - offsetY;
          // Constrain within board boundaries
          const maxX = board.clientWidth  - dragEl.offsetWidth;
          const maxY = board.clientHeight - dragEl.offsetHeight;
          if (newLeft < 0) newLeft = 0;
          if (newLeft > maxX) newLeft = maxX;
          if (newTop < 0) newTop = 0;
          if (newTop > maxY) newTop = maxY;
          // Apply translated position
          dragEl.style.left = newLeft + 'px';
          dragEl.style.top  = newTop  + 'px';
        });
        card.addEventListener('pointerup', e => {
          if (!dragEl || dragEl !== card) return;
          dragEl.releasePointerCapture(e.pointerId);
          endDrag();
        });
        card.addEventListener('pointercancel', e => {
          if (!dragEl || dragEl !== card) return;
          dragEl.releasePointerCapture(e.pointerId);
          endDrag();
        });
      });
    })();
  </script>
</body>
</html>

  </script>
</body>
</html>
