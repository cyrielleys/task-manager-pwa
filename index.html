<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>任务看板</title>
<style>
body {
  margin: 0;
  background: #000;
  color: #fff;
  font-family: Arial, sans-serif;
}
/* Top bar for adding tasks */
#topbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 50px;
  background: #111;
  display: flex;
  align-items: center;
  padding: 0 10px;
  z-index: 100;
}
#topbar input[type="text"] {
  background: #333;
  color: #fff;
  border: 1px solid #555;
  padding: 5px 8px;
  margin-right: 5px;
  border-radius: 4px;
}
#topbar input[type="text"]::placeholder {
  color: #aaa;
}
#topbar button {
  background: #333;
  color: #fff;
  border: 1px solid #555;
  padding: 5px 10px;
  margin-right: 5px;
  border-radius: 4px;
  cursor: pointer;
}
#topbar button:hover {
  background: #444;
}
/* Canvas area wrapper */
#wrapper {
  position: absolute;
  top: 50px;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: auto;
  overscroll-behavior: none;
}
#wrapper::-webkit-scrollbar {
  width: 0;
  height: 0;
}
#wrapper {
  scrollbar-width: none;
}
/* Canvas container */
#canvas {
  position: relative;
  width: 3000px;
  height: 2000px;
  /* Checkerboard background: black and 90% gray squares */
  background-color: #000;
  background-image: repeating-conic-gradient(#1a1a1a 0% 25%, #000 0% 50%);
  background-position: 50%;
  background-size: 132vw 132vw;
}
/* Task card style */
.task {
  position: absolute;
  background: #333;
  color: #fff;
  border: 1px solid #555;
  border-radius: 4px;
  padding: 5px;
  min-width: 150px;
  max-width: 300px;
  cursor: grab;
  user-select: none;
}
.task:active {
  cursor: grabbing;
}
/* Title and note inside task */
.task .title {
  font-weight: bold;
  margin-bottom: 4px;
}
.task .note {
  display: none;
  white-space: pre-wrap;
  word-break: break-word;
}
/* Expanded task shows note */
.task.expanded .note {
  display: block;
}
/* Small round buttons */
.task .expand-btn,
.task .delete-btn {
  position: absolute;
  top: 5px;
  width: 16px;
  height: 16px;
  border: none;
  border-radius: 50%;
  background: #555;
  color: #fff;
  font-size: 12px;
  line-height: 16px;
  text-align: center;
  cursor: pointer;
  padding: 0;
}
.task .expand-btn:hover,
.task .delete-btn:hover {
  background: #777;
}
.task .expand-btn {
  left: 5px;
}
.task .delete-btn {
  right: 5px;
}
</style>
</head>
<body>
<div id="topbar">
  <input type="text" id="titleInput" placeholder="标题">
  <input type="text" id="noteInput" placeholder="备注">
  <button id="addBtn">添加任务</button>
  <button id="exportBtn">导出</button>
  <button id="importBtn">导入</button>
</div>
<div id="wrapper">
  <div id="canvas"></div>
</div>
<script>
(() => {
  const canvas = document.getElementById('canvas');
  const wrapper = document.getElementById('wrapper');
  const titleInput = document.getElementById('titleInput');
  const noteInput = document.getElementById('noteInput');
  const addBtn = document.getElementById('addBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  
  const CANVAS_WIDTH = 3000;
  const CANVAS_HEIGHT = 2000;
  let tasksData = [];
  let nextId = 1;
  
  // Dragging state for task cards
  let draggingTask = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  // Panning state for canvas
  let isPanning = false;
  let panStartX = 0;
  let panStartY = 0;
  let panStartScrollLeft = 0;
  let panStartScrollTop = 0;
  
  // Create a task DOM element and attach events
  function createTaskElement(task) {
    const taskEl = document.createElement('div');
    taskEl.className = 'task' + (task.collapsed ? '' : ' expanded');
    taskEl.dataset.id = task.id;
    taskEl.style.left = task.x + 'px';
    taskEl.style.top = task.y + 'px';
    // Title text
    const titleEl = document.createElement('div');
    titleEl.className = 'title';
    titleEl.textContent = task.title;
    // Note text
    const noteEl = document.createElement('div');
    noteEl.className = 'note';
    noteEl.textContent = task.note;
    taskEl.appendChild(titleEl);
    taskEl.appendChild(noteEl);
    // Expand/collapse button
    const expandBtn = document.createElement('button');
    expandBtn.className = 'expand-btn';
    expandBtn.textContent = task.collapsed ? '＋' : '－';
    taskEl.appendChild(expandBtn);
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    taskEl.appendChild(deleteBtn);
    // Expand/collapse toggle
    expandBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const taskId = parseInt(taskEl.dataset.id);
      const data = tasksData.find(t => t.id === taskId);
      if (taskEl.classList.contains('expanded')) {
        taskEl.classList.remove('expanded');
        data.collapsed = true;
        expandBtn.textContent = '＋';
      } else {
        taskEl.classList.add('expanded');
        data.collapsed = false;
        expandBtn.textContent = '－';
      }
    });
    // Delete task
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const taskId = parseInt(taskEl.dataset.id);
      tasksData = tasksData.filter(t => t.id !== taskId);
      canvas.removeChild(taskEl);
    });
    // Task dragging pointer events
    taskEl.addEventListener('pointerdown', (e) => {
      if (e.target.classList.contains('expand-btn') || e.target.classList.contains('delete-btn')) {
        return; // ignore clicks on buttons
      }
      draggingTask = taskEl;
      // Bring element to front
      taskEl.style.zIndex = '1';
      // Calculate pointer offset inside the task element
      const rect = canvas.getBoundingClientRect();
      const pointerX = e.clientX - rect.left + wrapper.scrollLeft;
      const pointerY = e.clientY - rect.top + wrapper.scrollTop;
      const taskX = parseInt(taskEl.style.left, 10);
      const taskY = parseInt(taskEl.style.top, 10);
      dragOffsetX = pointerX - taskX;
      dragOffsetY = pointerY - taskY;
      e.preventDefault();
      taskEl.setPointerCapture(e.pointerId);
    });
    taskEl.addEventListener('pointermove', (e) => {
      if (!draggingTask || draggingTask !== taskEl) return;
      const rect = canvas.getBoundingClientRect();
      const pointerX = e.clientX - rect.left + wrapper.scrollLeft;
      const pointerY = e.clientY - rect.top + wrapper.scrollTop;
      // Compute new position within bounds
      let newX = pointerX - dragOffsetX;
      let newY = pointerY - dragOffsetY;
      const taskWidth = taskEl.offsetWidth;
      const taskHeight = taskEl.offsetHeight;
      if (newX < 0) newX = 0;
      if (newY < 0) newY = 0;
      if (newX + taskWidth > CANVAS_WIDTH) {
        newX = CANVAS_WIDTH - taskWidth;
      }
      if (newY + taskHeight > CANVAS_HEIGHT) {
        newY = CANVAS_HEIGHT - taskHeight;
      }
      taskEl.style.left = newX + 'px';
      taskEl.style.top = newY + 'px';
    });
    taskEl.addEventListener('pointerup', (e) => {
      if (draggingTask === taskEl) {
        const taskId = parseInt(taskEl.dataset.id);
        const data = tasksData.find(t => t.id === taskId);
        data.x = parseInt(taskEl.style.left, 10);
        data.y = parseInt(taskEl.style.top, 10);
      }
      draggingTask = null;
      taskEl.releasePointerCapture(e.pointerId);
      taskEl.style.zIndex = '';
    });
    canvas.appendChild(taskEl);
  }
  
  // Add new task
  addBtn.addEventListener('click', () => {
    const title = titleInput.value.trim();
    const note = noteInput.value.trim();
    if (!title) return;
    // Initial position (50px offset from current view)
    const startX = wrapper.scrollLeft + 50;
    const startY = wrapper.scrollTop + 50;
    const task = {
      id: nextId++,
      title: title,
      note: note,
      x: Math.min(startX, CANVAS_WIDTH - 200),
      y: Math.min(startY, CANVAS_HEIGHT - 100),
      collapsed: true
    };
    tasksData.push(task);
    createTaskElement(task);
    titleInput.value = '';
    noteInput.value = '';
  });
  
  // Export tasks to clipboard
  exportBtn.addEventListener('click', () => {
    const dataStr = JSON.stringify(tasksData);
    navigator.clipboard.writeText(dataStr).then(() => {
      alert('任务数据已复制到剪贴板');
    }).catch(err => {
      alert('复制失败：' + err);
    });
  });
  
  // Import tasks from clipboard
  importBtn.addEventListener('click', async () => {
    try {
      const text = await navigator.clipboard.readText();
      if (!text) {
        alert('剪贴板没有任务数据');
        return;
      }
      const imported = JSON.parse(text);
      if (!Array.isArray(imported)) {
        throw new Error('格式无效');
      }
      // Clear existing tasks
      tasksData = [];
      nextId = 1;
      document.querySelectorAll('.task').forEach(el => canvas.removeChild(el));
      // Load tasks from imported data
      imported.forEach(item => {
        if (typeof item.title !== 'string' || typeof item.note !== 'string' ||
            typeof item.x !== 'number' || typeof item.y !== 'number') {
          throw new Error('格式无效');
        }
        const task = {
          id: nextId++,
          title: item.title,
          note: item.note,
          x: Math.max(0, Math.min(item.x, CANVAS_WIDTH - 200)),
          y: Math.max(0, Math.min(item.y, CANVAS_HEIGHT - 100)),
          collapsed: item.collapsed !== false
        };
        tasksData.push(task);
        createTaskElement(task);
      });
    } catch (err) {
      alert('导入失败：' + err.message);
    }
  });
  
  // Canvas panning (drag to scroll)
  canvas.addEventListener('pointerdown', (e) => {
    if (e.target !== canvas) return;
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    panStartScrollLeft = wrapper.scrollLeft;
    panStartScrollTop = wrapper.scrollTop;
    canvas.style.cursor = 'grabbing';
    e.preventDefault();
  });
  window.addEventListener('pointermove', (e) => {
    if (!isPanning) return;
    const dx = e.clientX - panStartX;
    const dy = e.clientY - panStartY;
    wrapper.scrollLeft = panStartScrollLeft - dx;
    wrapper.scrollTop = panStartScrollTop - dy;
  });
  window.addEventListener('pointerup', () => {
    if (isPanning) {
      isPanning = false;
      canvas.style.cursor = '';
    }
  });
})();
</script>
</body>
</html>
