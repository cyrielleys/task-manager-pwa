<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Task Board PWA</title>
<style>
    /* Chessboard background for the board */
    #board {
        flex: 1;
        position: relative;
        overflow: auto;
        background-color: #f0f0f0;
        background-image: 
            linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc),
            linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc);
        background-size: 20px 20px;
        background-position: 0 0, 10px 10px;
    }
    /* Toolbar at top */
    #toolbar {
        background: #eee;
        padding: 5px;
        font-family: sans-serif;
    }
    #toolbar button {
        margin-right: 8px;
    }
    /* Task card styles */
    .task {
        position: absolute;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 8px 30px 8px 8px; /* right padding to accommodate buttons */
        box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        cursor: move;
        /* Note: not setting user-select: none here to allow text selection when not dragging */
        touch-action: none; /* prevent touch dragging from triggering page scroll */
    }
    .task.selected {
        border-color: #66f; /* highlight border when selected */
        box-shadow: 0 0 10px rgba(0,0,255,0.3);
    }
    .task .title {
        font-weight: bold;
        /* display: block; (default block for div) */
    }
    .task .note {
        margin-top: 4px;
        white-space: pre-wrap; /* preserve newlines if any and wrap text */
        display: none;
    }
    .task.expanded .note {
        display: block;
    }
    /* Positioning and style for task buttons */
    .task .delete-btn, .task .expand-btn {
        position: absolute;
        top: 4px;
        /* using font characters for icons */
        background: none;
        border: none;
        cursor: pointer;
        color: #666;
        font-size: 14px;
        line-height: 1;
        padding: 2px;
    }
    .task .delete-btn {
        right: 4px;
    }
    .task .expand-btn {
        right: 24px;
    }
    .task .delete-btn:hover, .task .expand-btn:hover {
        color: #000;
    }
</style>
</head>
<body>
<div id="toolbar">
    <button id="addBtn">Add Task</button>
    <button id="undoBtn" disabled>Undo</button>
    <button id="exportBtn">Export</button>
    <button id="importBtn">Import</button>
    <input type="file" id="fileInput" accept="application/json" style="display:none">
</div>
<div id="board"></div>
<script>
    /* Task board script */
    const board = document.getElementById('board');
    const addBtn = document.getElementById('addBtn');
    const undoBtn = document.getElementById('undoBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const fileInput = document.getElementById('fileInput');
    
    let tasksData = [];
    let history = [];
    // Use unique id for tasks
    let nextId = 1;
    // Track maximum z-index for stacking order
    let maxZ = 0;
    
    // Load tasks from localStorage if available
    const savedData = localStorage.getItem('tasks');
    if (savedData) {
        try {
            const parsed = JSON.parse(savedData);
            if (Array.isArray(parsed)) {
                tasksData = parsed;
                // determine nextId and maxZ from loaded tasks
                parsed.forEach(task => {
                    if (task.id >= nextId) nextId = task.id + 1;
                    if (task.z && task.z > maxZ) maxZ = task.z;
                });
            }
        } catch(e) {
            console.error('Failed to parse saved tasks:', e);
        }
    }
    // If no tasks loaded, initialize with sample tasks (optional)
    if (tasksData.length === 0) {
        tasksData = [
            { id: nextId++, title: "Task 1", note: "This is an example task card. It can be dragged around.", x: 50, y: 50, z: ++maxZ, expanded: true },
            { id: nextId++, title: "Task 2", note: "Drag me with your finger on a touchscreen!", x: 180, y: 150, z: ++maxZ, expanded: true },
            { id: nextId++, title: "Task 3", note: "My position will be saved and restored after reload.", x: 320, y: 250, z: ++maxZ, expanded: true }
        ];
    }
    
    // Push initial state to history for undo
    function pushHistoryState() {
        // Deep clone tasksData (structured clone via JSON)
        const stateCopy = JSON.parse(JSON.stringify(tasksData));
        history.push(stateCopy);
        // Limit history size if needed
        if (history.length > 100) {
            history.shift();
        }
        // Update undo button state
        undoBtn.disabled = history.length <= 1;
    }
    pushHistoryState();
    
    // Render all tasks from tasksData
    function renderTasks() {
        // Clear current tasks elements
        board.innerHTML = '';
        for (let task of tasksData) {
            const el = createTaskElement(task);
            board.appendChild(el);
        }
    }
    
    // Create a DOM element for a task and attach necessary event listeners
    function createTaskElement(task) {
        const taskEl = document.createElement('div');
        taskEl.className = 'task' + (task.expanded ? ' expanded' : '');
        taskEl.dataset.id = task.id;
        // Set position and stacking
        taskEl.style.left = task.x + 'px';
        taskEl.style.top = task.y + 'px';
        taskEl.style.zIndex = task.z || 1;
        // Task title element
        const titleEl = document.createElement('div');
        titleEl.className = 'title';
        titleEl.contentEditable = "true";
        titleEl.textContent = task.title;
        taskEl.appendChild(titleEl);
        // Task note element
        const noteEl = document.createElement('div');
        noteEl.className = 'note';
        noteEl.contentEditable = "true";
        noteEl.textContent = task.note;
        taskEl.appendChild(noteEl);
        // Expand button
        const expandBtn = document.createElement('button');
        expandBtn.className = 'expand-btn';
        expandBtn.textContent = task.expanded ? '▲' : '▼';
        taskEl.appendChild(expandBtn);
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = '×';
        taskEl.appendChild(deleteBtn);
        // Event: when title or note loses focus (after editing), update task data
        titleEl.addEventListener('blur', onContentEdit);
        noteEl.addEventListener('blur', onContentEdit);
        return taskEl;
    }
    
    // Handle content edit (title or note blur)
    function onContentEdit(e) {
        const taskEl = e.target.closest('.task');
        if (!taskEl) return;
        const taskId = Number(taskEl.dataset.id);
        const task = tasksData.find(t => t.id === taskId);
        if (!task) return;
        if (e.target.classList.contains('title')) {
            task.title = e.target.textContent;
        } else if (e.target.classList.contains('note')) {
            task.note = e.target.textContent;
        }
        // Save changes to localStorage and push history
        saveTasks();
        pushHistoryState();
    }
    
    // Save tasksData to localStorage
    function saveTasks() {
        localStorage.setItem('tasks', JSON.stringify(tasksData));
    }
    
    // Add task handler
    addBtn.addEventListener('click', () => {
        const newTask = {
            id: nextId++,
            title: "New Task",
            note: "",
            x: 60 + (tasksData.length * 10),
            y: 60 + (tasksData.length * 10),
            z: ++maxZ,
            expanded: false
        };
        tasksData.push(newTask);
        // Create and append new task element
        const taskEl = createTaskElement(newTask);
        board.appendChild(taskEl);
        // Save state
        saveTasks();
        pushHistoryState();
    });
    
    // Delete and expand via event delegation on board
    board.addEventListener('click', (e) => {
        const target = e.target;
        if (target.classList.contains('delete-btn')) {
            // Delete task
            const taskEl = target.closest('.task');
            if (!taskEl) return;
            const taskId = Number(taskEl.dataset.id);
            // Remove from tasksData
            const index = tasksData.findIndex(t => t.id === taskId);
            if (index >= 0) {
                tasksData.splice(index, 1);
            }
            // Remove element from DOM
            taskEl.remove();
            // Save and push history state
            saveTasks();
            pushHistoryState();
        } else if (target.classList.contains('expand-btn')) {
            // Toggle expand/collapse note
            const taskEl = target.closest('.task');
            if (!taskEl) return;
            const taskId = Number(taskEl.dataset.id);
            const task = tasksData.find(t => t.id === taskId);
            if (!task) return;
            if (taskEl.classList.contains('expanded')) {
                // collapse
                taskEl.classList.remove('expanded');
                target.textContent = '▼';
                task.expanded = false;
            } else {
                // expand
                taskEl.classList.add('expanded');
                target.textContent = '▲';
                task.expanded = true;
            }
            saveTasks();
            // (Note: expand/collapse is a view change, not pushing to history)
        }
    });
    
    // Undo handler
    undoBtn.addEventListener('click', () => {
        if (history.length <= 1) return;
        // Remove latest state
        history.pop();
        // Get previous state
        const prevState = history[history.length - 1];
        if (!prevState) return;
        // Restore tasksData and re-render
        tasksData = JSON.parse(JSON.stringify(prevState));
        // Recompute nextId and maxZ
        nextId = 1;
        maxZ = 0;
        tasksData.forEach(task => {
            if (task.id >= nextId) nextId = task.id + 1;
            if (task.z && task.z > maxZ) maxZ = task.z;
        });
        renderTasks();
        // Update localStorage to reflect undone state
        saveTasks();
        undoBtn.disabled = history.length <= 1;
    });
    
    // Export handler
    exportBtn.addEventListener('click', () => {
        const dataStr = JSON.stringify(tasksData);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "tasks.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });
    
    // Import handler
    importBtn.addEventListener('click', () => {
        fileInput.click();
    });
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const imported = JSON.parse(event.target.result);
                if (Array.isArray(imported)) {
                    tasksData = imported;
                    // Recompute nextId and maxZ
                    nextId = 1;
                    maxZ = 0;
                    tasksData.forEach(task => {
                        if (task.id >= nextId) nextId = task.id + 1;
                        if (task.z && task.z > maxZ) maxZ = task.z;
                    });
                    // Reset history and render imported tasks
                    history = [];
                    renderTasks();
                    saveTasks();
                    pushHistoryState();
                } else {
                    alert("Import failed: Invalid data format.");
                }
            } catch(err) {
                alert("Import failed: " + err);
            }
        };
        reader.readAsText(file);
    });
    
    // Drag-and-drop functionality (direct task dragging, removed canvas click-to-move)
    let draggedTaskEl = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    
    board.addEventListener('pointerdown', (e) => {
        // Only handle pointerdown on a task (or its children), not the board itself
        const taskEl = e.target.closest('.task');
        if (!taskEl) return;
        // If clicking on a button inside the task, do not initiate drag
        if (e.target.classList.contains('delete-btn') || e.target.classList.contains('expand-btn')) {
            return;
        }
        // Only respond to primary pointer (left mouse button or touch)
        if (e.button !== 0) return;
        // Prepare for dragging
        draggedTaskEl = taskEl;
        // Bring this task to top and highlight it
        const taskId = Number(taskEl.dataset.id);
        const task = tasksData.find(t => t.id === taskId);
        if (task) {
            taskEl.classList.add('selected');
            // Remove selection class from other tasks
            document.querySelectorAll('.task').forEach(el => {
                if (el !== taskEl) el.classList.remove('selected');
            });
            // Increase z-index for this task
            task.z = ++maxZ;
            taskEl.style.zIndex = task.z;
            saveTasks(); // save z-index change
        }
        // Calculate pointer offset inside the element
        const rect = taskEl.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        // Store initial pointer position for threshold
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        isDragging = false;
        // Capture pointer events to the task element (continues getting pointermove even if pointer leaves element)
        taskEl.setPointerCapture(e.pointerId);
    });
    
    board.addEventListener('pointermove', (e) => {
        if (!draggedTaskEl) return;
        // Prevent default to avoid text selection or other default actions
        e.preventDefault();
        // If not yet officially dragging, check if pointer moved beyond a few pixels
        if (!isDragging) {
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            if (Math.abs(dx) < 5 && Math.abs(dy) < 5) {
                return; // do not start drag until pointer moved enough
            }
            isDragging = true;
            // Once dragging starts, disable text selection to prevent highlighting
            document.body.style.userSelect = 'none';
            // Clear any existing text selection
            const sel = window.getSelection ? window.getSelection() : document.selection;
            if (sel) {
                if (sel.removeAllRanges) sel.removeAllRanges();
                else if (sel.empty) sel.empty();
            }
        }
        // Compute new position relative to board
        const boardRect = board.getBoundingClientRect();
        let newX = e.clientX - boardRect.left - dragOffsetX;
        let newY = e.clientY - boardRect.top - dragOffsetY;
        // Optionally, clamp newX/newY to board bounds if desired
        // newX = Math.max(0, Math.min(newX, board.clientWidth - draggedTaskEl.offsetWidth));
        // newY = Math.max(0, Math.min(newY, board.clientHeight - draggedTaskEl.offsetHeight));
        // Update element position
        draggedTaskEl.style.left = newX + 'px';
        draggedTaskEl.style.top = newY + 'px';
        // Update task data in memory
        const taskId = Number(draggedTaskEl.dataset.id);
        const task = tasksData.find(t => t.id === taskId);
        if (task) {
            task.x = newX;
            task.y = newY;
        }
    });
    
    board.addEventListener('pointerup', (e) => {
        if (!draggedTaskEl) return;
        // If a drag was in progress, finalize it
        if (isDragging) {
            saveTasks();       // save final position to storage
            pushHistoryState(); // record this move in history for undo
        }
        // Release pointer capture
        draggedTaskEl.releasePointerCapture(e.pointerId);
        // Clear dragging state
        draggedTaskEl = null;
        isDragging = false;
        // Re-enable text selection on page
        document.body.style.userSelect = '';
    });
    
    board.addEventListener('pointercancel', (e) => {
        // Handle touch cancel similar to pointerup
        if (draggedTaskEl) {
            if (isDragging) {
                saveTasks();
                pushHistoryState();
            }
            draggedTaskEl.releasePointerCapture(e.pointerId);
        }
        draggedTaskEl = null;
        isDragging = false;
        document.body.style.userSelect = '';
    });
    
    // Initial render of tasks on page load
    renderTasks();
</script>
</body>
</html>
