<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Task Board</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #fff;
    }
    #topbar {
      position: fixed; top: 0; left: 0; width: 100%;
      background: #f9f9f9; border-bottom: 1px solid #ccc;
      padding: 5px; box-sizing: border-box;
      z-index: 1000;
      display: flex; align-items: center;
    }
    #taskInput {
      flex: 1; padding: 6px;
      font-size: 14px; box-sizing: border-box;
    }
    #topbar button {
      margin-left: 5px; padding: 6px 10px;
      font-size: 14px; cursor: pointer;
    }
    #canvas-container {
      position: fixed; left: 0; right: 0; bottom: 0;
      /* top is set via script to the #topbar height */
      overflow: hidden; background: #eee;
    }
    #canvas {
      position: absolute; top: 0; left: 0;
      width: 600vw; height: 200vh;
      transform-origin: 0 0;
      touch-action: none;        /* Disable browser touch panning/zoom on canvas:contentReference[oaicite:3]{index=3} */
      will-change: transform;    /* Hint for smoother GPU-accelerated transforms */
      -webkit-transform: translateZ(0);
              transform: translateZ(0);  /* Use GPU layer to prevent Safari flicker */
    }
    .task {
      position: absolute;
      min-width: 100px; max-width: 300px;
      padding: 5px;
      background: #ffffe0;  /* light yellow background for tasks */
      border: 1px solid #ccc; border-radius: 4px;
      box-shadow: 1px 1px 5px rgba(0,0,0,0.15);
      cursor: grab;
      touch-action: none;
      user-select: none;
    }
    .task:active { cursor: grabbing; }
    .task-note {
      display: none;
      margin-top: 4px;
      font-size: 90%; color: #333;
      white-space: pre-wrap;
    }
    .task.expanded .task-note { display: block; }
    .delete-btn {
      position: absolute; top: 2px; right: 4px;
      padding: 0 4px;
      border: none; background: transparent;
      font-size: 14px; font-weight: bold; color: #888;
      cursor: pointer; user-select: none;
    }
  </style>
</head>
<body>
  <!-- Top fixed control bar -->
  <div id="topbar">
    <input type="text" id="taskInput" placeholder="Add a task..." />
    <button id="addBtn">Add</button>
    <button id="undoBtn" disabled>Undo</button>
    <button id="exportBtn">Export</button>
    <button id="importBtn">Import</button>
  </div>
  <!-- Canvas container (scrollable area) -->
  <div id="canvas-container">
    <div id="canvas"><!-- Task boxes will be appended here --></div>
  </div>
  <!-- Hidden file input for Import -->
  <input type="file" id="fileInput" accept=".json" style="display:none;" />
  <script>
    (() => {
      const topbar = document.getElementById('topbar');
      const container = document.getElementById('canvas-container');
      const canvas   = document.getElementById('canvas');
      const taskInput = document.getElementById('taskInput');
      const addBtn   = document.getElementById('addBtn');
      const undoBtn  = document.getElementById('undoBtn');
      const exportBtn= document.getElementById('exportBtn');
      const importBtn= document.getElementById('importBtn');
      const fileInput= document.getElementById('fileInput');

      // Adjust canvas-container top offset to leave room for the fixed topbar
      function resizeCanvasContainer() {
        container.style.top = topbar.offsetHeight + 'px';
      }
      resizeCanvasContainer();
      window.addEventListener('resize', resizeCanvasContainer);

      // Data structures
      let tasksData = [];
      let idCounter = 0;
      let lastDeleted = null;

      // Canvas transform state
      let transX = 0, transY = 0, scale = 1;
      const minScale = 0.5, maxScale = 3;

      // Drag/zoom state
      let isDraggingCanvas = false;
      let dragCanvasPointerId = null;
      let baseTransX = 0, baseTransY = 0;
      let dragStartX = 0, dragStartY = 0;
      let draggingTaskId = null;
      let dragTaskPointerId = null;
      let dragOffsetX = 0, dragOffsetY = 0;
      let dragStartPX = 0, dragStartPY = 0;
      let taskMoved = false;
      let pinchActive = false;
      let pinchPointers = [];
      let lastMidX = 0, lastMidY = 0;
      let lastDist = 0;
      const pointerPositions = {};

      // Canvas dimensions (px in content coords)
      const canvasWidth  = canvas.offsetWidth;
      const canvasHeight = canvas.offsetHeight;

      // Helper: create a task element and append to canvas
      function createTaskElement(task) {
        const el = document.createElement('div');
        el.className = 'task';
        el.setAttribute('data-id', task.id);
        el.textContent = task.text;
        if (task.note && task.note !== '') {
          // Add note sub-element if note text exists
          const noteDiv = document.createElement('div');
          noteDiv.className = 'task-note';
          noteDiv.textContent = task.note;
          el.appendChild(noteDiv);
        }
        // Delete button
        const delBtn = document.createElement('button');
        delBtn.className = 'delete-btn';
        delBtn.textContent = '×';
        // Prevent triggering drag events when touching the delete button
        delBtn.addEventListener('pointerdown', ev => ev.stopPropagation());
        el.appendChild(delBtn);
        // Position the task box
        el.style.left = task.x + 'px';
        el.style.top  = task.y + 'px';
        canvas.appendChild(el);
        return el;
      }

      // Add a new task from the input text
      function addTask(text) {
        if (!text) return;
        const task = { id: ++idCounter, text: text, note: '' };
        // Measure the task's size by creating a temporary hidden element
        const temp = document.createElement('div');
        temp.className = 'task';
        temp.style.visibility = 'hidden';
        temp.textContent = text;
        canvas.appendChild(temp);
        const newWidth  = temp.offsetWidth;
        const newHeight = temp.offsetHeight;
        canvas.removeChild(temp);
        // Determine initial position (center of current view)
        const viewRect = container.getBoundingClientRect();
        const visibleLeft = Math.max(0, -transX / scale);
        const visibleTop  = Math.max(0, -transY / scale);
        const visibleWidth  = viewRect.width / scale;
        const visibleHeight = viewRect.height / scale;
        let posX = visibleLeft + visibleWidth/2 - newWidth/2;
        let posY = visibleTop  + visibleHeight/2 - newHeight/2;
        // Clamp inside canvas
        posX = Math.max(0, Math.min(posX, canvasWidth - newWidth));
        posY = Math.max(0, Math.min(posY, canvasHeight - newHeight));
        // Avoid overlapping existing tasks
        let tries = 0;
        while (tries < 50) {
          let overlap = false;
          for (const t of tasksData) {
            const tRight = t.x + (t.width || 0);
            const tBottom = t.y + (t.height || 0);
            if (posX < tRight && posX + newWidth > t.x && posY < tBottom && posY + newHeight > t.y) {
              overlap = true;
              break;
            }
          }
          if (!overlap) break;
          posX += 30;
          posY += 30;
          if (posX + newWidth > canvasWidth) posX = 0;
          if (posY + newHeight > canvasHeight) posY = 0;
          tries++;
        }
        task.x = posX;
        task.y = posY;
        task.width  = newWidth;
        task.height = newHeight;
        tasksData.push(task);
        createTaskElement(task);
      }

      // Undo last deleted task
      function undoDelete() {
        if (!lastDeleted) return;
        const task = lastDeleted;
        lastDeleted = null;
        task.id = ++idCounter;  // assign new ID
        tasksData.push(task);
        createTaskElement(task);
        undoBtn.disabled = true;
      }

      // Export tasks to JSON file
      function exportTasks() {
        const data = tasksData.map(({ id, width, height, ...rest }) => rest);
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'tasks.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Import tasks from uploaded JSON text
      function importTasks(jsonText) {
        let imported = [];
        try {
          const data = JSON.parse(jsonText);
          imported = Array.isArray(data) ? data : (data.tasks || []);
        } catch (e) {
          alert('Invalid task file format!');
          return;
        }
        // Remove existing tasks from canvas
        for (const t of tasksData) {
          const el = canvas.querySelector('[data-id="' + t.id + '"]');
          if (el) canvas.removeChild(el);
        }
        tasksData = [];
        lastDeleted = null;
        undoBtn.disabled = true;
        // Add imported tasks
        for (const t of imported) {
          const task = {
            id: ++idCounter,
            text: t.text || '', 
            note: t.note || '',
            x: Math.max(0, Math.min(t.x || 0, canvasWidth - 1)),
            y: Math.max(0, Math.min(t.y || 0, canvasHeight - 1))
          };
          tasksData.push(task);
          const el = createTaskElement(task);
          // Store element’s size for future placement calculations
          task.width  = el.offsetWidth;
          task.height = el.offsetHeight;
        }
      }

      // Topbar button event handlers
      addBtn.addEventListener('click', () => {
        addTask(taskInput.value.trim());
        taskInput.value = '';
      });
      taskInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          addTask(taskInput.value.trim());
          taskInput.value = '';
        }
      });
      undoBtn.addEventListener('click', undoDelete);
      exportBtn.addEventListener('click', exportTasks);
      importBtn.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => { importTasks(e.target.result); };
        reader.readAsText(file);
        fileInput.value = '';  // reset input
      });

      // Delegate click on delete buttons to handle task deletion
      container.addEventListener('click', e => {
        if (e.target.classList.contains('delete-btn')) {
          const taskElem = e.target.closest('.task');
          if (!taskElem) return;
          const taskId = Number(taskElem.getAttribute('data-id'));
          const idx = tasksData.findIndex(t => t.id === taskId);
          if (idx >= 0) {
            lastDeleted = tasksData[idx];
            tasksData.splice(idx, 1);
          }
          canvas.removeChild(taskElem);
          undoBtn.disabled = !lastDeleted;
        }
      });

      // Pointer events for dragging and zooming
      container.addEventListener('pointerdown', e => {
        if (e.button !== undefined && e.button !== 0) return;  // only handle primary pointer
        // If a second finger touches during canvas drag -> start pinch zoom
        if (!pinchActive && isDraggingCanvas && dragCanvasPointerId && e.pointerId !== dragCanvasPointerId) {
          pinchActive = true;
          pinchPointers = [dragCanvasPointerId, e.pointerId];
          pointerPositions[e.pointerId] = { x: e.clientX, y: e.clientY };
          const p1 = pointerPositions[pinchPointers[0]];
          const p2 = pointerPositions[pinchPointers[1]];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          lastDist = Math.hypot(dx, dy);
          lastMidX = (p1.x + p2.x) / 2;
          lastMidY = (p1.y + p2.y) / 2;
          // End single-finger panning
          isDraggingCanvas = false;
          dragCanvasPointerId = null;
          return;
        }
        // If already dragging a task, ignore additional pointers
        if (draggingTaskId !== null && e.pointerId !== dragTaskPointerId) {
          return;
        }
        const target = e.target;
        const taskElem = target.closest('.task');
        if (taskElem && taskElem.parentElement === canvas) {
          // Begin dragging a task box
          draggingTaskId = Number(taskElem.getAttribute('data-id'));
          dragTaskPointerId = e.pointerId;
          // Bring task to front
          taskElem.style.zIndex = '500';
          // Calculate pointer offset within the task (in content coordinates)
          const pointerX = (e.clientX - transX) / scale;
          const pointerY = (e.clientY - transY) / scale;
          const task = tasksData.find(t => t.id === draggingTaskId);
          dragOffsetX = pointerX - task.x;
          dragOffsetY = pointerY - task.y;
          dragStartPX = e.clientX;
          dragStartPY = e.clientY;
          taskMoved = false;
          container.setPointerCapture(e.pointerId);
        } else {
          // Begin dragging (panning) the whole canvas
          isDraggingCanvas = true;
          dragCanvasPointerId = e.pointerId;
          baseTransX = transX;
          baseTransY = transY;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          container.setPointerCapture(e.pointerId);
        }
        // Track this pointer’s position
        pointerPositions[e.pointerId] = { x: e.clientX, y: e.clientY };
      });

      container.addEventListener('pointermove', e => {
        if (pinchActive && pinchPointers.length === 2) {
          // Multi-touch pinch zoom/pan
          if (pointerPositions[e.pointerId]) {
            // update this pointer's stored position
            pointerPositions[e.pointerId].x = e.clientX;
            pointerPositions[e.pointerId].y = e.clientY;
          }
          const [id1, id2] = pinchPointers;
          const p1 = pointerPositions[id1], p2 = pointerPositions[id2];
          if (!p1 || !p2) return;
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const dist = Math.hypot(dx, dy);
          if (dist === 0) return;
          // Scale ratio since last event
          const ratio = dist / lastDist;
          let newScale = scale * ratio;
          newScale = Math.max(minScale, Math.min(maxScale, newScale));
          const actualRatio = newScale / scale;
          // Adjust translation to zoom around midpoint
          const newTransX = transX + (1 - actualRatio) * (midX - transX);
          const newTransY = transY + (1 - actualRatio) * (midY - transY);
          // Account for midpoint movement (pan)
          transX = newTransX + (midX - lastMidX);
          transY = newTransY + (midY - lastMidY);
          scale = newScale;
          // Apply transform
          canvas.style.transform = `scale(${scale}) translate3d(${transX}px, ${transY}px, 0)`;
          // Update baseline for next move
          lastMidX = midX;
          lastMidY = midY;
          lastDist = dist;
          e.preventDefault();
        } else if (draggingTaskId !== null && e.pointerId === dragTaskPointerId) {
          // Dragging an individual task
          const pointerX = (e.clientX - transX) / scale;
          const pointerY = (e.clientY - transY) / scale;
          const task = tasksData.find(t => t.id === draggingTaskId);
          // Compute new position
          let newX = pointerX - dragOffsetX;
          let newY = pointerY - dragOffsetY;
          // Clamp within canvas bounds
          newX = Math.max(0, Math.min(newX, canvasWidth - (task.width || 0)));
          newY = Math.max(0, Math.min(newY, canvasHeight - (task.height || 0)));
          // Update data and element
          task.x = newX;
          task.y = newY;
          const elem = canvas.querySelector('[data-id="' + task.id + '"]');
          if (elem) {
            elem.style.left = newX + 'px';
            elem.style.top  = newY + 'px';
          }
          // Check if pointer moved enough to be a drag (not a tap)
          if (!taskMoved) {
            const moveDX = e.clientX - dragStartPX;
            const moveDY = e.clientY - dragStartPY;
            if (Math.hypot(moveDX, moveDY) > 5) {
              taskMoved = true;
            }
          }
          e.preventDefault();
        } else if (isDraggingCanvas && e.pointerId === dragCanvasPointerId) {
          // Panning the entire canvas
          const dx = e.clientX - dragStartX;
          const dy = e.clientY - dragStartY;
          transX = baseTransX + dx;
          transY = baseTransY + dy;
          canvas.style.transform = `scale(${scale}) translate3d(${transX}px, ${transY}px, 0)`;
          e.preventDefault();
        }
      });

      container.addEventListener('pointerup', e => {
        if (pinchActive && pinchPointers.includes(e.pointerId)) {
          // One touch lifted during pinch
          pinchPointers = pinchPointers.filter(id => id !== e.pointerId);
          if (pinchPointers.length < 2) {
            pinchActive = false;
            if (pinchPointers.length === 1) {
              // Continue dragging canvas with remaining finger
              const remainingId = pinchPointers[0];
              isDraggingCanvas = true;
              dragCanvasPointerId = remainingId;
              dragStartX = pointerPositions[remainingId].x;
              dragStartY = pointerPositions[remainingId].y;
              baseTransX = transX;
              baseTransY = transY;
            }
          }
        }
        if (e.pointerId === dragTaskPointerId && draggingTaskId !== null) {
          // Finished dragging a task
          const taskElem = canvas.querySelector('[data-id="' + draggingTaskId + '"]');
          if (taskElem) taskElem.style.zIndex = '';  // reset stacking
          if (!taskMoved) {
            // Treat as a click -> toggle note
            if (taskElem) {
              if (taskElem.classList.contains('expanded')) {
                taskElem.classList.remove('expanded');
              } else {
                const noteDiv = taskElem.querySelector('.task-note');
                if (noteDiv) {
                  taskElem.classList.add('expanded');
                }
              }
              // Update stored task height (in case note expanded/collapsed)
              const tdata = tasksData.find(t => t.id === draggingTaskId);
              if (tdata) {
                tdata.height = taskElem.offsetHeight;
              }
            }
          }
          draggingTaskId = null;
          dragTaskPointerId = null;
        }
        if (e.pointerId === dragCanvasPointerId && isDraggingCanvas) {
          // Finished panning canvas
          isDraggingCanvas = false;
          dragCanvasPointerId = null;
        }
        if (container.hasPointerCapture(e.pointerId)) {
          container.releasePointerCapture(e.pointerId);
        }
        delete pointerPositions[e.pointerId];
      });

      container.addEventListener('pointercancel', e => {
        // Clean up if pointer is unexpectedly interrupted
        if (pinchPointers.includes(e.pointerId)) {
          pinchPointers = pinchPointers.filter(id => id !== e.pointerId);
          pinchActive = false;
        }
        if (e.pointerId === dragTaskPointerId) {
          draggingTaskId = null;
          dragTaskPointerId = null;
        }
        if (e.pointerId === dragCanvasPointerId) {
          isDraggingCanvas = false;
          dragCanvasPointerId = null;
        }
        if (container.hasPointerCapture(e.pointerId)) {
          container.releasePointerCapture(e.pointerId);
        }
        delete pointerPositions[e.pointerId];
      });

      // Enable wheel zoom (for desktop)
      container.addEventListener('wheel', e => {
        e.preventDefault();
        if (e.deltaY === 0) return;
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        let newScale = scale * zoomFactor;
        newScale = Math.max(minScale, Math.min(maxScale, newScale));
        const factor = newScale / scale;
        // Zoom around pointer position
        const mouseX = e.clientX, mouseY = e.clientY;
        const contentX = (mouseX - transX) / scale;
        const contentY = (mouseY - transY) / scale;
        scale = newScale;
        transX = mouseX - contentX * scale;
        transY = mouseY - contentY * scale;
        canvas.style.transform = `scale(${scale}) translate3d(${transX}px, ${transY}px, 0)`;
      });

      // Prevent long-press context menu on canvas (for touch devices)
      window.addEventListener('contextmenu', e => {
        if (e.target.closest('#canvas')) e.preventDefault();
      });
    })();
  </script>
</body>
</html>
